# Concurrency

**Database concurrency** refers to situations in which multiple processes **access or change the same data** in a database at the same time.

- EF Core implements optimistic concurrency control, and it means that multiple processes or users can make changes independently without the overhead of synchronization or locking.
- In the ideal situation, these changes will not interfere with each other and therefore will be able to succeed
- In the worst-case scenario, two or more processes will attempt to make conflicting changes, and only one of them should succeed.

## Concurrency Control

**Concurrency control** refers to specific mechanisms used to ensure data consistency in presence of concurrent changes.

To implement optimistic concurrency control, you need to **configure properties as concurrency tokens.** So, whenever an **_update or delete_** operation is performed during `SaveChanges`, the value of the concurrency token on the database is compared against the original value read by EF Core.

- If the values match, the operation can complete.
- If the values do not match, EF Core assumes that another user has performed a conflicting operation and **_aborts the current transaction (throw `DbUpdateConcurrencyException`)._**
- Database providers are responsible for implementing the comparison of concurrency token values.

---

- On relational databases EF Core includes a check for the value of the concurrency token in the `WHERE` clause of any `UPDATE` or `DELETE` statements. After executing the statements, EF Core reads the number of rows that were affected.
- If no rows are affected, a concurrency conflict is detected, and EF Core throws `DbUpdateConcurrencyException`.

---

## Configure Concurrency Tokens

In EF Core, there are two approaches to detect concurrency conflict detection

- Configuring existing properties as concurrency tokens
- Adding a new "rowversion" property to act as a concurrency token.

### Configure Existing Properties

- Data Annotation

```csharp
// Data Annotation

public class Person
{
    public int Id { get; set; }

    [ConcurrencyCheck] public string FirstName { get; set; }

    public string LastName { get; set; }
}
```

```csharp
// Fluent API

public class Person
{
    public int Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }
}

protected override void OnModelCreating(ModelBuilder builder)
{
    builder.Entity<Person>()
        .Property(c => c.FirstName).IsConcurrencyToken();
}
```

In this example, if one user tries to save some changes to a `Person`, but another user has already changed the `FirstName`, then an exception will be thrown.

## Add `Timestamp/RowVersion` **Property**

- A `timestamp/RowVersion` is a property for which a new value is automatically generated by the database every time a row is inserted or updated.
- The property is also treated as a concurrency token, ensuring that you get an exception if a row you are updating has changed since you queried it.
- The database provider is responsible to achieve this, for SQL Server, it is usually used on a byte[] property, which will be setup as a `ROWVERSION` column in the database.

```csharp
// Data Annotaction

public class Person
{
    public int Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }

    [Timestamp] public byte[] Timestamp { get; set; } // can be called anything
}
```

```csharp
// Fluent API

public class Person
{
    public int Id { get; set; }

    public string FirstName { get; set; }

    public string LastName { get; set; }

    public byte[] Timestamp { get; set; } // can be called anything
}

protected override void OnModelCreating(ModelBuilder builder)
{
    builder.Entity<Blog>()
        .Property(p => p.Timestamp).IsRowVersion();
}
```

## Resolving Concurrency Conflicts

- When concurrency conflict occurs, the application could simply inform the user that the update was not successful due to conflicting changes and move on. But it may be desirable to prompt the user to ensure this record still represents the same actual person and to retry the operation.
- Resolving a concurrency conflict involves merging the pending changes from the current `DbContext` with the values in the database. What values get merged will vary based on the application and may be directed by user input.

---

**_There are three sets of values available to help resolve a concurrency conflict:_**

- **Current values** are the values that the application was attempting to write to the database.
- **Original values** are the values that were originally retrieved from the database, before any edits were made.
- **Database values** are the values currently stored in the database.

---

### The general approach to handle a concurrency conflict is:

1. Catch `DbUpdateConcurrencyException` during `SaveChanges`.
2. Use `DbUpdateConcurrencyException.Entries` to prepare a new set of changes for the affected entities.
3. Refresh the original values of the concurrency token to reflect the current values in the database.
4. Retry the process until no conflicts occur.

In the following example, `Person.FirstName` and `Person.LastName` are set up as concurrency tokens. There is a `// TODO:` comment in the location where you include application specific logic to choose the value to be saved.

```csharp
using (var context = new ApplicationDbContext())
{
    // Fetch a person from database and change phone number
    var person = context.People.Single(p => p.PersonId == 1);
    person.PhoneNumber = "555-555-5555";

    // Change the person's name in the database to simulate a concurrency conflict
    context.Database.ExecuteSqlRaw(
        "UPDATE dbo.People SET FirstName = 'Jane' WHERE PersonId = 1");

    var saved = false;
    while (!saved)
    {
        try
        {
            // Attempt to save changes to the database
            context.SaveChanges();
            saved = true;
        }
        catch (DbUpdateConcurrencyException ex)
        {
            foreach (var entry in ex.Entries)
            {
                if (entry.Entity is Person)
                {
                    var proposedValues = entry.CurrentValues;
                    var databaseValues = entry.GetDatabaseValues();

                    foreach (var property in proposedValues.Properties)
                    {
                        var proposedValue = proposedValues[property];
                        var databaseValue = databaseValues[property];

                        // TODO: decide which value should be written to database
                        // proposedValues[property] = <value to be saved>;
                    }

                    // Refresh original values to bypass next concurrency check
                    entry.OriginalValues.SetValues(databaseValues);
                }
                else
                {
                    throw new NotSupportedException(
                        "Don't know how to handle concurrency conflicts for "
                        + entry.Metadata.Name);
                }
            }
        }
    }
}
```

## References

[https://docs.microsoft.com/en-us/ef/core/saving/concurrency](https://docs.microsoft.com/en-us/ef/core/saving/concurrency)

[https://entityframeworkcore.com/saving-data-concurrency](https://entityframeworkcore.com/saving-data-concurrency)

[https://docs.microsoft.com/en-us/ef/core/modeling/concurrency](https://docs.microsoft.com/en-us/ef/core/modeling/concurrency?tabs=data-annotations)
